% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{get.optimal_clustering}
\alias{get.optimal_clustering}
\title{Optimal Hierarchical Clustering Based on Consistency Metrics}
\usage{
get.optimal_clustering(
  X = NULL,
  scTypeEval,
  sample = "sample",
  reduction = TRUE,
  ndim = 30,
  gene.list = NULL,
  min.cells = 10,
  min.samples = 5,
  clustering_method = c("kmeans", "leiden"),
  consistency_method = c("silhouette | RecipClassif:Match",
    "2label.silhouette | Pseudobulk:Cosine"),
  hvg.ngenes = 2000,
  normalization.method = "Log1p",
  ncores = 1,
  max_Nclusters = 100,
  max_iter = 100,
  nstart = 30,
  epsilon = 0.2,
  min.consistency = 0.5,
  weight_by = c("none", "cells", "samples"),
  verbose = TRUE
)
}
\arguments{
\item{X}{Optional numeric matrix of features (cells as rows, features as columns).
Usually a low dimensional embeddings for all cells of datasets are expected.
If \code{NULL}, the function preprocesses the provided \code{scTypeEval} object
using \code{process_clustering()} to obtain a PCA embedding or filtered matrix.}

\item{scTypeEval}{A \code{scTypeEval} object containing raw or processed
single-cell data and metadata.}

\item{sample}{Character string specifying the metadata column containing
sample identifiers.}

\item{reduction}{Logical; if \code{TRUE}, PCA is performed during preprocessing
when \code{X} is not provided (default: \code{TRUE}).}

\item{ndim}{Integer; number of principal components to retain when
\code{reduction = TRUE} (default: \code{30}).}

\item{gene.list}{Optional named list of gene sets used for consistency
computation. If \code{NULL}, highly variable genes (HVGs) are computed.}

\item{min.cells}{Integer; minimum number of cells required per cluster
to be considered during consistency computation (default: \code{10}).}

\item{min.samples}{Integer; minimum number of samples required per cluster
for consistency evaluation (default: \code{5}).}

\item{clustering_method}{Character string specifying the clustering algorithm
used for splitting. Currently supported: \code{"kmeans"}.
\code{"leiden"} is reserved for future implementation.}

\item{consistency_method}{Character vector specifying consistency metrics to
evaluate cluster splits. Each entry must follow the format
\code{"<metric> | <dissimilarity.method>"}.}

\item{hvg.ngenes}{Integer; number of highly variable genes to select when
\code{gene.list = NULL} (default: \code{2000}).}

\item{normalization.method}{Character string specifying the normalization
method used during preprocessing (default: \code{"Log1p"}).}

\item{ncores}{Integer; number of CPU cores for parallel execution
(default: \code{1}).}

\item{max_Nclusters}{Integer; maximum number of clusters allowed before
stopping the hierarchical splitting process (default: \code{100}).}

\item{max_iter}{Integer; maximum number of hierarchical splitting iterations
(default: \code{100}).}

\item{nstart}{Integer; number of random starts for k-means clustering
(default: \code{30}).}

\item{epsilon}{Numeric; tolerance allowing child cluster consistency to be
slightly lower than the parent cluster consistency (default: \code{0.2}).}

\item{min.consistency}{Numeric; minimum consistency score required for a
cluster to be retained in the final solution (default: \code{0.5}).}

\item{weight_by}{Character string specifying how to aggregate child
consistency scores when evaluating a split:
\itemize{
\item \code{"none"} — unweighted mean
\item \code{"cells"} — weighted by number of cells
\item \code{"samples"} — weighted by number of samples
}}

\item{verbose}{Logical; if \code{TRUE}, prints progress messages
(default: \code{TRUE}).}
}
\value{
An updated \code{scTypeEval} object containing:
\itemize{
\item A new metadata column \code{optimal} with the selected clustering labels
\item Intermediate hierarchical clustering assignments
\item Consistency results stored in \code{scTypeEval@consistency}
}
}
\description{
An automated clustering procedure that iteratively splits cell populations
into subclusters and selects an optimal clustering resolution based on
cluster consistency metrics.

This function performs a top-down hierarchical clustering strategy,
evaluates each split using one or more consistency metrics,
and retains only those splits that improve or maintain consistency above
user-defined thresholds. The final output is an \code{scTypeEval} object
annotated with an optimal clustering assignment.
}
\details{
The algorithm proceeds as follows:
\enumerate{
\item Preprocesses the data if \code{X} is not provided
\item Initializes all cells into a root cluster
\item Iteratively splits clusters into subclusters
\item Computes consistency metrics for each split using
\code{compute_consistency()}
\item Retains splits that satisfy consistency improvement and threshold
criteria
\item Reverts clusters failing \code{min.consistency} to their parent cluster
}

This strategy identifies a data-driven clustering resolution without
requiring the number of clusters to be specified a priori.
}
\examples{
\dontrun{
scTypeEval <- optimal_clustering(
  scTypeEval = sc_obj,
  ident = "celltype",
  sample = "sample_id",
  consistency_method = c(
    "silhouette | RecipClassif:Match",
    "2label.silhouette | Pseudobulk:Cosine"
  ),
  min.consistency = 0.6,
  verbose = TRUE
)

table(scTypeEval@metadata$optimal)
}

}
\seealso{
\code{\link{process_clustering}},
\code{\link{compute_consistency}},
\code{\link{get.clusters}}
}
